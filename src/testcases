 // ---------------------------
        // Program
        // --------------------------


// ADDI R1, R0, 5
memory[0]  = 32'h28020005;   // R1 = 5

// ADDI R2, R0, 10
memory[1]  = 32'h2804000A;   // R2 = 10

// ADD R3, R1, R2
memory[2]  = 32'h00062280;   // R3 = 15

// -------------------------------------------------
// Memory
// -------------------------------------------------

// SW R3, 4(R0)
memory[3]  = 32'h50060004;

// LW R4, 4(R0)
memory[4]  = 32'h48080004;

// -------------------------------------------------
// CALL test
// -------------------------------------------------

// CALL +4   ? jump to PC = 9
memory[5]  = 32'h60000004;

// Instruction after CALL (should execute *after return*)
memory[6]  = 32'h280A0001;   // ADDI R5, R0, 1

// ADD R6, R4, R5
memory[7]  = 32'h000C5080;

// NOP
memory[8]  = 32'h00000000;

// -------------------------------------------------
// CALL target (subroutine)
// -------------------------------------------------

// ADDI R7, R0, 3
memory[9]  = 32'h280E0003;

// ADD R8, R7, R1
memory[10] = 32'h00101080;

// SUB R9, R8, R2
memory[11] = 32'h08123080;

// -------------------------------------------------
// Return
// -------------------------------------------------

// JR R31
memory[12] = 32'h68000000;

// -------------------------------------------------
// Post-return code (MUST run)
// -------------------------------------------------

// AND R10, R6, R3
memory[13] = 32'h20145080;

// OR R11, R10, R5
memory[14] = 32'h28165080;

// NOPs (clean end)
// -------------------------------------------------
memory[15] = 32'h00000000;
memory[16] = 32'h00000000;




// -------------------------------------------------
    // RP TEST PROGRAM (NORMAL INSTRUCTIONS)
    // -------------------------------------------------
    
    // R4 = 0   (predicate false)
    memory[0] = 32'h28080000;  
    // ADDI Rd=R4, Rs=R0, imm=0, Rp=R0
    
    // R1 = 1   (predicate true)
    memory[1] = 32'h28020001;  
    // ADDI Rd=R1, Rs=R0, imm=1, Rp=R0
    
    // -------------------------------------------------
    // Rp = R0 ? MUST execute
    // -------------------------------------------------
    
    memory[2] = 32'h28040005;  
    // ADDI Rd=R2, Rs=R0, imm=5, Rp=R0
    // EXPECT: R2 = 5
    
    // -------------------------------------------------
    // Rp = R1 (true) ? execute
    // -------------------------------------------------
    
    memory[3] = 32'h28460007;  
    // ADDI Rd=R3, Rs=R0, imm=7, Rp=R1
    // EXPECT: R3 = 7
    
    // -------------------------------------------------
    // Rp = R4 (false) ? squash
    // -------------------------------------------------
    
    memory[4] = 32'h29080009;  
    // ADDI Rd=R4, Rs=R0, imm=9, Rp=R4
    // EXPECT: R4 unchanged (still 0)
    
    // -------------------------------------------------
    // R-type, Rp = false ? squash
    // -------------------------------------------------
    
    memory[5] = 32'h008A5080;  
    // ADD Rd=R5, Rs=R1, Rt=R2, Rp=R4
    // EXPECT: R5 unchanged
    
    // -------------------------------------------------
    // R-type, Rp = true ? execute
    // -------------------------------------------------
    
    memory[6] = 32'h004C5080;  
    // ADD Rd=R6, Rs=R1, Rt=R2, Rp=R1
    // EXPECT: R6 = 1 + 5 = 6
    
    // -------------------------------------------------
    // LW, Rp = false ? squash
    // -------------------------------------------------
    
    memory[7] = 32'h490E0004;  
    // LW Rd=R7, Rs=R0, imm=4, Rp=R4
    // EXPECT: no memory read, R7 unchanged
    
    // -------------------------------------------------
    // LW, Rp = true ? execute
    // -------------------------------------------------
    
    memory[8] = 32'h48AE0004;  
    // LW Rd=R7, Rs=R0, imm=4, Rp=R1
    // EXPECT: R7 loaded
    
    // -------------------------------------------------
    // SW, Rp = false ? squash
    // -------------------------------------------------
    
    memory[9] = 32'h510E0008;  
    // SW Rs=R7, imm=8, Rp=R4
    // EXPECT: no memory write
    
    // -------------------------------------------------
    // SW, Rp = true ? execute
    // -------------------------------------------------
    
    memory[10] = 32'h50AE0008;  
    // SW Rs=R7, imm=8, Rp=R1
    // EXPECT: memory updated
    
    // -------------------------------------------------
    // Clean end
    // -------------------------------------------------
    memory[11] = 32'h00000000;
    memory[12] = 32'h00000000;


// 0: R1 = 1
memory[0] = 32'h28020001;   // ADDI R1,R0,1

// 1: CALL +4  (your current PC math may land at 5; that's fine)
// return address should be 2 in R31
memory[1] = 32'h60000004;   // CALL imm=4

// 2: should run AFTER return
memory[2] = 32'h28040009;   // ADDI R2,R0,9  (watch this happen after JR)

// 3-5 filler
memory[3] = 32'h00000000;
memory[4] = 32'h00000000;
memory[5] = 32'h00000000;

// 6: subroutine body
memory[6] = 32'h2808002A;   // ADDI R4,R0,42

// 7: RETURN
memory[7] = 32'h6801F000;   // JR R31   <<< THIS is the return

// 8: wrong-path instruction (should be killed by JR)
memory[8] = 32'h280A0063;   // ADDI R5,R0,99 (should NOT execute if JR works)



